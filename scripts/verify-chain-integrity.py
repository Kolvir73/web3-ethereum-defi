"""Verify an EVM blockchain full node integrity over JSON-RPC API.

Perform fetches of random blocks and recipies to see the node contains all the data,
up to the latest block. Uses parallel workers to speed up the checks.

The script contains heurestics whether or not block comes from a "good" full node
with all transaction receipts intact, not pruned. There are also other various failure
modes like RPC nodes just failing to return core data (e.g. polygon-rpc.com).

Examples are for UNIX shell.

First set up your JSON-RPC connection secrets:

    export JSON_RPC_URL=https://polygon-rpc.com/

Run a check for 100 randomly selected blocks:

    CHECK_COUNT=100 python scripts/verify-chain-integrity.py

Run in a single-thread example, good for debugging):

.. code-block:: shell

    MAX_WORKERS=1 python scripts/verify-chain-integrity.py

In the end the script prints:

.. code-block:: text


"""
import os
import random
from dataclasses import dataclass
from itertools import starmap
from typing import List, Tuple, Optional

import futureproof
import requests
from eth.constants import ZERO_ADDRESS
from hexbytes import HexBytes
from web3 import Web3, HTTPProvider
from web3.exceptions import TransactionNotFound

from eth_defi.event_reader.conversion import convert_jsonrpc_value_to_int
from eth_defi.event_reader.web3factory import TunedWeb3Factory


@dataclass
class BlockIntegrityFailure:
    """Describe block data errors."""

    block_number: int


@dataclass
class LogsMissing(BlockIntegrityFailure):
    """We could find any logs in the block."""

    def __repr__(self):
        return f"Block {self.block_number:,} - no logs"


@dataclass
class TransactionMissing(BlockIntegrityFailure):
    """Node could not serve the transaction by its hash"""

    tx_hash: HexBytes

    def __repr__(self):
        return f"Block {self.block_number:,} - could not fetch transaction data for transaction {self.tx_hash.hex()}"


@dataclass
class ReceiptMissing(BlockIntegrityFailure):
    """Node could not serve the transaction receipt"""

    tx_hash: HexBytes

    def __repr__(self):
        return f"Block {self.block_number:,} - could not fetch transaction receipt for transaction {self.tx_hash.hex()}"


@dataclass
class CodeMissing(BlockIntegrityFailure):
    """Node could not serve the smart contract code"""

    address: str

    def __repr__(self):
        return f"Block {self.block_number:,} - could not fetch smart contract cpde for address {self.address}"


def check_block(web3_factory, block_no: int, max_tx_checks=20) -> Optional[BlockIntegrityFailure]:
    """A worker function to check the integrity of a specific block over EVM-compatible JSON-RPC.

    - Check block data downloads (should always happen)

    - Check receipts download (only if your node is not pruned)

    :return:
        None on success (block contains logs).

        For failures return tuple (block number, transaction hash)
    """
    web3 = web3_factory()
    block = web3.eth.get_block(block_no)

    # Verify block integrity by checking it has a timestamp
    timestamp = convert_jsonrpc_value_to_int(block["timestamp"])
    assert timestamp > 0  # Not going to happen, but let's just check for something

    # Pick a random transaction.
    # Here we make some heurestics what we assume is a good transactoin.
    # - Check the transaction is a smart contract transaction
    # - Assume transaction may or may not event emits
    txs = block["transactions"]
    if len(txs) < 2:
        # Ignore first tx which is always coinbase tx
        print(f"Block {block_no:,} ok - no transactions")
        return None

    # Try to find at least one transaction with logs
    for attempt in range(max_tx_checks):
        tx_hash = random.choice(txs)

        try:
            tx = web3.eth.get_transaction(tx_hash)
        except TransactionNotFound as e:
            # TransactionNotFound is generated by so-called null result formatter in
            # web3._utils.method_formatters - it means JSON-RPC returned a zero byte response.
            # In these cases we do not retry, because if a node ha
            return TransactionMissing(block_no, tx_hash)

        target_address = tx["to"]
        if target_address == ZERO_ADDRESS:
            # Contract deployment tx
            continue

        if target_address is None:
            # Not sure what tx type, but happens,
            # prolly someone made a broken tx?
            continue

        # If transaction was pure value transfer and not to smart contract,]
        # it cannot emit logs
        try:
            code = web3.eth.get_code(target_address)
        except Exception as e:
            # Not sure under which conditions this happen but add some more context
            # info to the exception
            return CodeMissing(block_no, target_address)

        if len(code) == 0:
            # Not a smart contract target,
            # tx to another EOA
            continue

        try:
            receipt = web3.eth.get_transaction_receipt(tx_hash)
        except TransactionNotFound as e:
            # TransactionNotFound is generated by so-called null result formatter in
            # web3._utils.method_formatters - it means JSON-RPC returned a zero byte response.
            # In these cases we do not retry, because if a node has an error condition
            # it should return HTTP error, not zero byte response.
            return ReceiptMissing(block_no, tx_hash)

        if len(receipt["logs"]) > 0:
            # We have logs for this log - the block is correctly indexed
            # and not pruned
            print(f"Block {block_no:,} ok - has logs")
            return None

    print(f"WARNING Block {block_no:,} - could not find any transaction with logs")
    return LogsMissing(block_no)


def main():

    check_count = int(os.environ.get("CHECK_COUNT", "10000"))

    json_rpc_url = os.environ.get("JSON_RPC_URL")

    max_workers = int(os.environ.get("MAX_WORKERS", "10"))

    assert json_rpc_url, f"You need to give JSON_RPC_URL environment variable pointing ot your full node"

    # Setup connection
    web3 = Web3(HTTPProvider(json_rpc_url))

    # Clear AttributedDict middleware that slows us down
    web3.middleware_onion.clear()

    # Set up HTTP connection pool parameters and factory
    # for creating web3 connections inside worker threads
    http_adapter = requests.adapters.HTTPAdapter(pool_connections=max_workers, pool_maxsize=max_workers)
    # Special Web3 factory function that is
    # - optimised for speed of JSON-RPC
    # - can gracefully throttle when API rate limit reached
    web3_factory = TunedWeb3Factory(json_rpc_url, http_adapter, thread_local_cache=True)
    web3 = web3_factory()

    # Always check block 1 because it is most likely to fail
    last_block = web3.eth.block_number

    print(f"Chain {web3.eth.chain_id}, checking block range 1 - {last_block:,}")

    # List of (web3 factory, block number) tuples
    task_args: List[Tuple[TunedWeb3Factory, int]] = []

    # Always check block 1 as it is most likely to fail
    # This check does not go through the thread pool
    check_block(web3_factory, 1)

    # Set up the task queue for checks
    for check_no in range(check_count):
        task_args.append((web3_factory, random.randint(2, last_block)))

    # Order checks by a block number
    task_args = sorted(task_args, key=lambda t: t[1])

    print(f"Checking {len(task_args):,} blocks")

    if max_workers > 1:
        print(f"Doing multithread scan using {max_workers} works")
        # Do a parallel scan for the maximum speed
        #
        # Set up a futureproof task manager
        #
        # For futureproof usage see
        # https://github.com/yeraydiazdiaz/futureproof
        executor = futureproof.ThreadPoolExecutor(max_workers=max_workers)
        tm = futureproof.TaskManager(executor, error_policy=futureproof.ErrorPolicyEnum.RAISE)

        # Run the checks parallel using the thread pool
        tm.map(check_block, task_args)

        # Extract results from the parallel task queue
        results = [task.result for task in tm.as_completed()]

    else:
        print("Doing single thread scan")
        # Do single thread - good for debuggers like pdb/ipdb
        #
        iter = starmap(check_block, task_args)

        # Force workers to finish
        results = list(iter)

    # Count failures
    failed_blocks = [b for b in results if b is not None]
    failure_rate = len(failed_blocks) / check_count
    print(f"Finished, found {len(failed_blocks):,} uncertain/failed blocks out of {check_count:,} with the failure rate of {failure_rate * 100:.1f}%")
    if failed_blocks:
        print("Double check uncertain blocks manually and with a block explorer:")
        failure_reason: BlockIntegrityFailure
        for failure_reason in failed_blocks:
            print(f"    {failure_reason}")


if __name__ == "__main__":
    main()
